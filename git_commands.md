* git init – инициализация локального repository
* git checkout *<название ветки>* – переход к другой ветке
* git status – получить информацию от git о его текущем состоянии
* git add *<имя файла>* – добавить файл или файлы к следующему коммиту
* git add . - добавить все имеющиеся файлы к следующему коммиту
* git log – вывод на экран истории всех коммитов с их хеш-кодами
* git branch – посмотреть список веток в репозитории
* git branch *<название ветки>* – создать новую ветку
* git checkout -b *<название ветки>* - создать новую ветку и сразу на нее перейти
* git commit -m *“message”* – создание коммита.
* git commit -a - открывается текстовый редактор в терминале для записи комментария к коммиту. Для перехода в режим редактирования shift+I (появляется строка с сообщением --вставка-- или --insert--). после завершения записи на английской раскладке esc, shift+:(где буква Ж)wq, enter. Эта команда совмещает в себе две команды: git add . и git commit -m
* git commit -am "*комментарий*" - совмещает две команды git add . и git commit -m "*комментарий*"
* git branch -d *<название ветки>* – удалить ветку
* git log --oneline - журнал в компактном варианте
* git log --graph - журнал в графическом отображении
* git rebase - (перебазировать) копирует набор коммитов и переносит их в другое место, c его помощью можно делать чистые и красивые линейные последовательности коммитов
* git reset HEAD~1 - (сброс) отменяет изменения, перенося ссылку на ветку назад, на более старый коммит. работает на локальных ветках, в локальных репозиториях. Но этот метод переписывания истории не сработает на удалённых ветках, которые используют другие пользователи. в примере перенесет ссылку текущей ветки на предыдущий коммит от HEAD
* git revert HEAD - (возвращаться) отмена изменений, перенесёт ветку назад, как будто некоторых коммитов вовсе и не было. Появляется новый коммит, который содержит изменения, полностью противоположные тем, что сделаны в коммите, который отменяем. После revert можно сделать push и поделиться изменениями с остальными.
## Commands for working with remote repositories
* git remote add origin *<путь к удаленному репозиторию>* - добавление локального репозитория в удаленный репозиторий 
* git branch -M main - создание ветки на удаленном репозитории, на которую будет залит локальный репозиторий, где main - название создаваемой ветки
* git push -u origin main - заливка локального репозитория на удаленный на указанную ветку
* git push - (push - толкать, направлять) залить изменения с локального на удаленный репозиторий
* git push --set-upstream origin *<название ветки>* - залить изменения на новой ветке локального репозитория на удаленный с созданиемновой ветки
* git pull - (pull - тянуть) - залить и сразу смёржить изменения с удаленного репозитория на локальный. Обратить внимание, что в данном случае **возможны конфликты**, которые потребуют разрешения, как при выполнении команды git merge
* git clone *<путь к уаделенному репозиторию>* - клонирование удаленного репозитория на локальный компьютер с инициализацией склонированного репозитория на локальном компьютере. Обратить внимаение, что дальнейшей работы с клонированным репозиторием необходимо **перейти в папку с клонированным репозиторием**

HEAD - это символическое имя текущего выбранного коммита — это, по сути, тот коммит, над которым мы в данным момент работаем
* git checkout *<название ветки>*^ - Перемещение на один коммит назад, например main^ - переход к первому родителю ветки main, main^^ - переход к прародителю ветки main, или при помощи HEAD, например git checkout *<хэш-ссылка на коммит>* - переместили HEAD на нужный коммит, git checkout HEAD^
* git checkout *<название ветки или HEAD>*~*<num>* - Перемещение на несколько коммитов назад
* git branch -f main HEAD~3 - при помощи опции -f можно напрямую прикрепить ветку к коммиту. В данном примере переместит (принудительно) ветку main на три родителя назад от HEAD. f от forcing (принуждение)
