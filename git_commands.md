* git init – инициализация локального repository
* git checkout *<название ветки>* – переход к другой ветке
* git status – получить информацию от git о его текущем состоянии
* git add *<имя файла>* – добавить файл или файлы к следующему коммиту
* git add . - добавить все имеющиеся файлы к следующему коммиту
* git rm --cached <file> - остановить отслеживание файла
* git rm -r --cached <folder> - остановить отслеживание папки. Удаление файла из заголовка ревизии произойдет при следующем коммите. ВНИМАНИЕ: Хотя это не удалит физический файл из вашего локального, он будет удалять файлы с машин других разработчиков при следующем git pull
* git log – вывод на экран истории всех коммитов с их хеш-кодами
* git branch – посмотреть список веток в репозитории
* git branch *<название ветки>* – создать новую ветку
* git checkout -b *<название ветки>* - создать новую ветку и сразу на нее перейти
* git checkout -b *<название ветки>* *<хэш-сумма коммита>* - создать новую ветку с указанного коммита и сразу на нее перейти
* git commit -m *“message”* – создание коммита.
* git commit -a - выполняет команду add . (добавляет все файлы к комиту) и открывает текстовый редактор в терминале для записи комментария к коммиту. Для перехода в режим редактирования shift+I (появляется строка с сообщением --вставка-- или --insert--). после завершения записи на английской раскладке esc, shift+:(где буква Ж)wq, enter. Эта команда совмещает в себе две команды: git add . и git commit -m
* git commit -am "*комментарий*" - совмещает две команды git add . и git commit -m "*комментарий*"
* git branch -d *<название ветки>* – удалить ветку
* git log --oneline - журнал в компактном варианте
* git log --graph - журнал в графическом отображении
* git reset HEAD~1 - (сброс) отменяет изменения, перенося ссылку на ветку назад, на более старый коммит. работает на локальных ветках, в локальных репозиториях. Но этот метод переписывания истории не сработает на удалённых ветках, которые используют другие пользователи. в примере перенесет ссылку текущей ветки на предыдущий коммит от HEAD. При этом коммит не удаляется, к нему можно вернуться по хеш-сумме.
* git reset --hard *<хэш-сумма коммита>*- благодаря параметру hard проигнорируются все правки и указатель текущей ветки (HEAD + наим ветки) будет смещен на указанный коммит. Предыдущие коммиты при этом останутся, но их не будет видно. вернуться к ним можно только по хэш-суммам.
* git revert HEAD - (возвращаться) отмена изменений, перенесёт ветку назад, как будто некоторых коммитов вовсе и не было. Появляется новый коммит, который содержит изменения, полностью противоположные тем, что сделаны в коммите, который отменяем. После revert можно сделать push и поделиться изменениями с остальными.
* git checkout *<название **файла**>* - состояние файла вернется к состоянию последнего коммита в текущей ветке
* git restore - аналогично предыдущей
* git cherry-pick <Commit1> <Commit2> <...> - перемещение изменений - копировать несколько коммитов на место, где сейчас находишься (HEAD) - создаются клоны коммитов в текущее место текущей ветки
* git rebase *<название ветки>* - (перебазировать) копирует набор коммитов и переносит их в другое место, c его помощью можно делать чистые и красивые линейные последовательности коммитов. Находясь на ветке, например new-api (откуда перебазируем коммиты в указанную ветку), указываем название ветки в команде, например master, тогда git найдет общий родительский коммит этих двух веток и скопирует с новыми хэшами недостающие коммиты в указанную ветку из ветки, на которой находится. Скопированные коммиты не удаляются, но т.к. они не прикреплены ни к одной ветке, перейти на них можно т.зная их хэш, а также они не будут запушены на удаленный репозиторий.
* git rebase -i HEAD~4 - опция i откроет интерфейс просмотра (в редакторе типа vim) того, какие коммиты готовы к копированию на цель rebase (target). Также показываются хеши коммитов и комментарии к ним. * Можно сменить положение коммита по порядку, переставив строчку с ним в редакторе. * Можно "выкинуть" коммит из ребейза. Для этого есть pick - переключение его означает, что нужно выкинуть коммит. * можно соединить коммиты. Git копирует коммиты, как было указано через интерфейс. (всегда можно исправить ошибку, вызвав команду undo или reset)
* git push origin master -f - например мы запушили коммиты на сервер (появился указатель origin/*new-api*), потом сделали rebase, т.е. удаленный репозторий ссылается на один коммит, а локальный - на другой. если сделать пуш, то он будет отклонен, тогда применяется параметр force - git push origin master -f - сервер перепишет историю в удаленной ветке new-api и она будет полностью повторять локальную ветку. Крайне осторожно с этой командой. 
* если хотим добавить в main только исправление ошибки из ветки bugFix. Если мы воспользуемся простым fast-forward, то в main попадут также отладочные команды. Надо заставить git копировать только один из коммитов. Можно использовать уже команды: git rebase -i и git cherry-pick.
* git tag v1 C1 - создание тега на ветке C1, который будет версией 1 и будет ссылаться на C1 явным образом. Если конкретный коммит не указан, гит пометит тегом HEAD. Задача тега – ссылаться постоянно на конкретный коммит.После создания они никогда не сменят своего положения, и всегда можно сделать checkout конкретного момента в истории изменений
* теги могут быть аннотированные и легковесные. Легковесные - просто указатель с выбранным названием (git tag v1 - создание тега на текущем коммите). Аннотированные - полновесные объекты в гите, у них есть хэш сумма, указан автор, дата и т.д. (git tag -a *<название тега>* -m "комментарий") 
* git tag - выводит журнал тегов
* git push origin *<имя тега>* или git push origin --tags - По умолчанию теги на сервер не отправляются. Чтобы запушить их используется команда git push origin, если --tags - все теги отправятся на сервер.
* git describe <ref> - показывает, как далеко текущее состояние от ближайшего тега, где ref — это что-либо, что указывает на конкретный коммит. Если не указать ref, то git будет считать, что указано текущее положение (HEAD). Вывод команды примерно: <tag>_<numCommits>_g<hash>, Где tag – это ближайший тег в истории изменений, numCommits – это на сколько далеко мы от этого тега, а hash – это хеш текущего коммита.
* git bisect - ?
* git checkout main^2 - Так же как тильда (~), каретка (^) принимает номер после себя. Но в отличие от количества коммитов, на которые нужно откатиться назад (как делает ~), номер после ^ определяет, на какого из родителей мерджа надо перейти. По умолчанию git перейдёт на "первого" родителя коммита, при указании номера после ^ переходит на указанного родителя.
* git checkout HEAD~^2~2 - можно совмещать оба модификатора ~ ^. В данном случае будет переход указателясначала на 1 коммит назад, потом на второго родителя и еще на 2 коммита назад.

## Commands for working with remote repositories
  Удалённые ветки отражают состояние удалённых репозиториев (с того момента, как вы обращались к этим удалённым репозиториям в последний раз). Они позволяют вам отслеживать и видеть разницу между вашими локальными наработками и тем, что было сделано другими участниками - важный шаг, который необходимо делать, прежде чем делиться своими наработками с другими.

Важным свойством удалённых веток является тот факт, что когда вы извлекаете их, вы отделяете (detaching) HEAD. Git делает это потому, что вы не можете работать непосредственно в этих ветках; сперва вам необходимо сделать наработки где-либо, а уж затем делиться ими с удалёнными репозиториями (после чего ваши удалённые ветки будут обновлены).
  Удалённые ветки также имеют (обязательное) правило именования - они отображаются в формате: <удалённый репозиторий>/<имя ветки>
  
* git remote add origin *<путь к удаленному репозиторию>* - добавление локального репозитория в рабочую область для заливки на удаленный репозиторий 
* git branch -M main - создание ветки на удаленном репозитории, на которую будет залит локальный репозиторий, где main - название создаваемой ветки
* git push -u origin main - заливка локального репозитория на удаленный на указанную ветку. При этом локально создается новый указатель ветки remotes/origin/main - ветка слежения (remote reference)
* git push - (push - толкать, направлять) залить изменения с локального на удаленный репозиторий
git push origin *<название ветки>* - заливка изменений на удаленный репозиторий на указанной ветке
* git push --set-upstream origin *<название ветки>* - залить изменения на новой ветке локального репозитория на удаленный с созданием новой ветки. Этот указатель перемещать сами не можем, он нужен, чтобы понимать на каком коммите находится указатель ветки на удаленном репозитории
* git push --set-upstream origin main - git свяжет локальную ветку main с удаленной веткой main, эту команду можно выполнить один раза и далее использовать git push, находясь на ветке main
* git pull - (pull - тянуть) - залить и сразу смёржить изменения с удаленного репозитория на локальный. Обратить внимание, что в данном случае **возможны конфликты**, которые потребуют разрешения, как при выполнении команды git merge
* git pull origin *<название ветки>* - залить и смёржить изменения с удаленного репозитория на локальный с указанной ветки в текущую?
* git clone *<путь к уаделенному репозиторию>* - клонирование удаленного репозитория на локальный компьютер с инициализацией склонированного репозитория на локальном компьютере. Обратить внимаение, что дальнейшей работы с клонированным репозиторием необходимо **перейти в папку с клонированным репозиторием**
* git fetch - получить актуальную информацию о состоянии удаленных веток. При этом с указателями локальных веток ничего не произойдет. Эта команда обновляет ветки слежения, т.е. если кто-то сделал пуш в ветку, git скачает недостающие коммиты и передвинет ветки слежения. Чтобы увидеть эти коммиты, нужно смёржить свою локальную ветку с удаленной git merge origin/main 
* git fetch origin - получить актуальную информацию о состоянии удаленных веток, если есть несколько удаленных репозиториев (в качестве параметра передать имя репозитория). т.е. если кто-то сделал push в ветку, при выполнении этой команды гит скачает недостающие коммиты и передвинет ветки слежения. Чтобы увидеь эти коммиты у себя на локальной ветке, нужно сделать git merge origin/main - произойдет fastforvard - указатель HEAD просто переедет на merge commit - эти две команды в выполняет git pull
* git checkout *<название ветки на github>* - если на удаленном репозитории появилась новая ветка, после git pull на лоальном репозитории git отметит, что появилась новая ветка, но не покажет. командой git checkout свяжутся ветки локально и удаленно. 
* чтобы защитить ветку в GitHub можно создать правило для ветки: на нужном удаленном репозитории переходим в настройки - ветки - Branch protection rules - add rule - имя паттерна (или ветки) - create - теперь даже после принудительного пуша с параметром -f (force), правки не будут приняты сервером
* git checkout <origin> <main> - git отделил (detached) HEAD и не обновил o/main, когда мы добавили новый коммит. Всё потому, что o/main обновится тогда и только тогда, когда обновится сам удалённый репозиторий.
* git push remote_name -d remote_branch_name - удалить ветку на удаленном репозитории

HEAD - это символическое имя текущего выбранного коммита — это, по сути, тот коммит, над которым мы в данным момент работаем
* git checkout *<название ветки>*^ - Перемещение на один коммит назад, например main^ - переход к первому родителю ветки main, main^^ - переход к прародителю ветки main, или при помощи HEAD, например git checkout *<хэш-ссылка на коммит>* - переместили HEAD на нужный коммит, git checkout HEAD^
* git checkout *<название ветки или HEAD>*~*<num>* - Перемещение на несколько коммитов назад
* git branch -f main HEAD~3 - при помощи опции -f можно напрямую прикрепить ветку к коммиту. В данном примере переместит (принудительно) ветку main на три родителя назад от HEAD. f от forcing (принуждение)
* git remote -v - 
* git checkout *<название новой ветки на удаленном репозитории>* - выполняется после 
