* git init – инициализация локального repository
* git checkout *<название ветки>* – переход к другой ветке
* git status – получить информацию от git о его текущем состоянии
* git add *<имя файла>* – добавить файл или файлы к следующему коммиту
* git add . - добавить все имеющиеся файлы к следующему коммиту
* git log – вывод на экран истории всех коммитов с их хеш-кодами
* git branch – посмотреть список веток в репозитории
* git branch *<название ветки>* – создать новую ветку
* git checkout -b *<название ветки>* - создать новую ветку и сразу на нее перейти
* git checkout -b *<название ветки>* *<хэш-сумма коммита>* - создать новую ветку с указанного коммита и сразу на нее перейти
* git commit -m *“message”* – создание коммита.
* git commit -a - открывается текстовый редактор в терминале для записи комментария к коммиту. Для перехода в режим редактирования shift+I (появляется строка с сообщением --вставка-- или --insert--). после завершения записи на английской раскладке esc, shift+:(где буква Ж)wq, enter. Эта команда совмещает в себе две команды: git add . и git commit -m
* git commit -am "*комментарий*" - совмещает две команды git add . и git commit -m "*комментарий*"
* git branch -d *<название ветки>* – удалить ветку
* git log --oneline - журнал в компактном варианте
* git log --graph - журнал в графическом отображении
* git rebase - (перебазировать) копирует набор коммитов и переносит их в другое место, c его помощью можно делать чистые и красивые линейные последовательности коммитов
* git reset HEAD~1 - (сброс) отменяет изменения, перенося ссылку на ветку назад, на более старый коммит. работает на локальных ветках, в локальных репозиториях. Но этот метод переписывания истории не сработает на удалённых ветках, которые используют другие пользователи. в примере перенесет ссылку текущей ветки на предыдущий коммит от HEAD. При этом коммит не удаляется, к нему можно вернуться по хеш-сумме.
* git reset --hard *<хэш-сумма коммита>*- благодаря параметру hard проигнорируются все правки и указатель текущей ветки (HEAD + наим ветки) будет смещен на указанный коммит. Предыдущие коммиты при этом останутся, но их не будет видно. вернуться к ним можно только по хэш-суммам.
* git revert HEAD - (возвращаться) отмена изменений, перенесёт ветку назад, как будто некоторых коммитов вовсе и не было. Появляется новый коммит, который содержит изменения, полностью противоположные тем, что сделаны в коммите, который отменяем. После revert можно сделать push и поделиться изменениями с остальными.
* git checkout *<название **файла**>* - состояние файла вернется к состоянию последнего коммита в текущей ветке
* git restore - аналогично предыдущей
## Commands for working with remote repositories
* git remote add origin *<путь к удаленному репозиторию>* - добавление локального репозитория в рабочую область для заливки на удаленный репозиторий 
* git branch -M main - создание ветки на удаленном репозитории, на которую будет залит локальный репозиторий, где main - название создаваемой ветки
* git push -u origin main - заливка локального репозитория на удаленный на указанную ветку. При этом локально создается новый указатель ветки remotes/origin/main - ветка слежения (remote reference)
* git push - (push - толкать, направлять) залить изменения с локального на удаленный репозиторий
* git push --set-upstream origin *<название ветки>* - залить изменения на новой ветке локального репозитория на удаленный с созданием новой ветки. Этот указатель перемещать сами не можем, он нужен, чтобы понимать на каком коммите находится указатель ветки на удаленном репозитории
* git pull - (pull - тянуть) - залить и сразу смёржить изменения с удаленного репозитория на локальный. Обратить внимание, что в данном случае **возможны конфликты**, которые потребуют разрешения, как при выполнении команды git merge
* git pull origin *<название ветки>* - залить и смёржить изменения с удаленного репозитория на локальный с указанной ветки в текущую?
* git clone *<путь к уаделенному репозиторию>* - клонирование удаленного репозитория на локальный компьютер с инициализацией склонированного репозитория на локальном компьютере. Обратить внимаение, что дальнейшей работы с клонированным репозиторием необходимо **перейти в папку с клонированным репозиторием**
* git fetch - получить актуальную информацию о состоянии удаленных веток. При этом с указателями локальных веток ничего не произойдет. Эта команда обновляет ветки слежения, т.е. если кто-то сделал пуш в ветку, git скачает недостающие коммиты и передвинет ветки слежения. Чтобы увидеть эти коммиты, нужно смёржить свою локальную ветку с удаленной git merge origin/main 
* git fetch origin - получить актуальную информацию о состоянии удаленных веток, если есть несколько удаленных репозиториев (в качестве параметра передать имя репозитория). т.е. если кто-то сделал push в ветку, при выполнении этой команды гит скачает недостающие коммиты и передвинет ветки слежения. Чтобы увидеь эти коммиты у себя на локальной ветке, нужно сделать git merge origin/main - произойдет fastforvard - указатель HEAD просто переедет на merge commit - эти две команды в выполняет git pull

HEAD - это символическое имя текущего выбранного коммита — это, по сути, тот коммит, над которым мы в данным момент работаем
* git checkout *<название ветки>*^ - Перемещение на один коммит назад, например main^ - переход к первому родителю ветки main, main^^ - переход к прародителю ветки main, или при помощи HEAD, например git checkout *<хэш-ссылка на коммит>* - переместили HEAD на нужный коммит, git checkout HEAD^
* git checkout *<название ветки или HEAD>*~*<num>* - Перемещение на несколько коммитов назад
* git branch -f main HEAD~3 - при помощи опции -f можно напрямую прикрепить ветку к коммиту. В данном примере переместит (принудительно) ветку main на три родителя назад от HEAD. f от forcing (принуждение)
* git remote -v - 
